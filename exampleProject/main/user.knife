// User resource handling
// Manages all HTTP operations for user objects

// Import schema validations
import "@schema/user"

// Middleware for access control
middleware authenticate(request, next) {
    if !request.headers.authorization {
        respond 401 "Authentication required"
    }

    try {
        request.auth = verifyToken(request.headers.authorization)
        return next()
    } catch TokenError as err {
        respond 401 "Invalid authentication token: ${err.message}"
    }
}

middleware requireAdmin(request, next) {
    ensure request.auth?.role == "admin"
        else respond 403 "Admin access required"
    return next()
}

// Create user
on POST users(request) {
    try {
        // Schema validation is automatic based on user.slice

        // Check for duplicate email (in case unique constraint isn't handled at DB level)
        existing = db.users.findOne({ email: request.resource.email })
        if existing {
            respond 409 "A user with this email already exists"
        }

        // Hash password before storing
        // (bcrypt directive in schema handles this automatically)

        // Set creation timestamp
        // (auto_now directive in schema handles this automatically)

        // Create user in database
        userId = db.users.create(request.resource)

        // Generate verification token
        token = generateVerificationToken(userId)

        // Queue email sending task
        queue("send_verification_email", {
            to: request.resource.email,
            token: token,
            username: request.resource.username
        })

        respond 201 {
            body: {
                message: "User created successfully",
                userId: userId
            },
            headers: {
                "Location": "/users/${userId}"
            }
        }
    } catch ValidationError as err {
        respond 400 {
            status: "error",
            message: "Validation failed",
            details: err.details
        }
    } catch error {
        logException("User creation failed: ${error}")
        respond 500 "Internal server error"
    }
}

// Get user by ID
on GET users/:id => authenticate (request) {
    userId = request.params.id

    // Check permissions
    if request.auth.userId != userId && !["admin", "moderator"].includes(request.auth.role) {
        respond 403 "Not authorized to access this user"
    }

    user = db.users.findOne({ _id: userId })
    if !user {
        respond 404 "User not found"
    }

    // Remove sensitive data for non-self requests
    if request.auth.userId != userId && request.auth.role != "admin" {
        user.remove(["password", "email", "phone"])
    }

    // Always remove password hash
    user.remove(["password"])

    return user
}

// Update user
on PUT users/:id => authenticate (request) {
    userId = request.params.id

    // Permission check
    if request.auth.userId != userId && request.auth.role != "admin" {
        respond 403 "Not authorized to update this user"
    }

    // Get existing user
    user = db.users.findOne({ _id: userId })
    if !user {
        respond 404 "User not found"
    }

    // Field restrictions for non-admin users
    if request.auth.role != "admin" {
        // Regular users can't change their role or status
        request.resource.remove(["role", "status", "verified"])
    }

    // Update user
    db.users.update(userId, request.resource)

    // If email was changed, reset verification
    if request.resource.email && request.resource.email != user.email {
        db.users.update(userId, { verified: false })

        // Generate new verification token
        token = generateVerificationToken(userId)

        // Queue email verification
        queue("send_verification_email", {
            to: request.resource.email,
            token: token,
            username: request.resource.username || user.username
        })
    }

    respond 200 "User updated successfully"
}

// Delete user
on DELETE users/:id => authenticate (request) {
    userId = request.params.id

    // Only admins or the user themselves can delete
    if request.auth.userId != userId && request.auth.role != "admin" {
        respond 403 "Not authorized to delete this user"
    }

    // Find user to confirm existence
    user = db.users.findOne({ _id: userId })
    if !user {
        respond 404 "User not found"
    }

    // Delete user
    db.users.delete(userId)

    // If self-deletion, invalidate token
    if request.auth.userId == userId {
        invalidateToken(request.headers.authorization)
    }

    respond 204 // No content response for successful deletion
}

// Get all users (admin only)
on GET users => authenticate, requireAdmin (request) {
    // Pagination
    let {
        page = 1,
        limit = 20,
        sort = "created_at",
        order = "desc"
    } = request.query

    // Convert to numbers
    page = int(page)
    limit = int(limit)

    // Apply filters if provided
    filters = {}
    if request.query.role {
        filters.role = request.query.role
    }
    if request.query.status {
        filters.status = request.query.status
    }

    // Get users with pagination
    users = db.users.find(filters)
        .sort({ [sort]: order == "desc" ? -1 : 1 })
        .skip((page - 1) * limit)
        .limit(limit)
        .project({ password: 0 }) // Exclude password

    // Get total count for pagination
    total = db.users.count(filters)

    return {
        users: users,
        pagination: {
            total: total,
            pages: Math.ceil(total / limit),
            current_page: page,
            per_page: limit
        }
    }
}

// Verify email
on GET verify_email(request) {
    token = request.query.token
    if !token {
        respond 400 "Missing verification token"
    }

    try {
        // Verify token and get user ID
        userId = verifyEmailToken(token)

        // Update user verification status
        db.users.update(userId, { verified: true })

        // Redirect to frontend verification success page
        redirect "/verification-success"
    } catch error {
        logWarn("Invalid verification attempt: ${error}")
        redirect "/verification-failed"
    }
}

// Reset password request
on POST password_reset_request(request) {
    email = request.body.email
    if !email {
        respond 400 "Email is required"
    }

    user = db.users.findOne({ email: email })
    if user {
        // Generate password reset token
        token = generatePasswordResetToken(user._id)

        // Queue password reset email
        queue("send_password_reset", {
            to: email,
            token: token,
            username: user.username
        })
    }

    // Always respond positively for security (even if user doesn't exist)
    respond 200 "If your email is registered, you will receive a password reset link"
}

// Handle global errors for all user routes
catch ALL users/:id (request, error) {
    logException("User operation error: ${error.stack}")

    // Return appropriate error based on type
    if error instanceof DatabaseError {
        respond 503 "Service temporarily unavailable"
    } else if error instanceof ValidationError {
        respond 400 error.message
    } else {
        respond 500 "Could not process your request"
    }
}
